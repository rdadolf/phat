#include <string>
#include <stdlib.h>
#include <assert.h>
#include <map>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <signal.h>
#include "mpfd.hh"
#include "json.hh"
#include <netdb.h>
#include <errno.h>
#include "rpc_msg.hh"
#include "log.hh"
#include "network.hh"

namespace puppet {

////////////////////////////////////////////////////////////////////////////////


class Puppet
{
private:
  msgpack_fd mpfd_;
  pid_t child_process_;
public:
  Puppet();
  ~Puppet();

  // Setup operations
  void spawn(String command);
  tamed void connect(String hostname, int port, tamer::event<> ev);
  void disconnect();

  // Basic operations
  tamed void send_print(String name, tamer::event<> ev);
  tamed void send_die(tamer::event<> ev);
  tamed void send_sleep(int seconds, tamer::event<> ev);

  // Client operations
  tamed void send_getroot(String lhs, tamer::event<> ev);
  tamed void send_open(String lhs, String root, String subpath, tamer::event<> ev);
  tamed void send_mkfile(String lhs, String path, String data, tamer::event<> ev);
  tamed void send_mkdir(String lhs, String path, tamer::event<> ev);
  tamed void send_getcontents(String lhs, String path, tamer::event<> ev);
  tamed void send_putcontents(String lhs, String path, String data, tamer::event<> ev);
  tamed void send_readdir(String lhs, String path, tamer::event<> ev);
  tamed void send_stat(String lhs, String path, tamer::event<> ev);
  tamed void send_remove(String lhs, String path, tamer::event<> ev);
  // FIXME: the rest...
};


// Setup Operations 

Puppet::Puppet()
{
  child_process_ = 0;
}

Puppet::~Puppet()
{
  disconnect();
  if(child_process_>0) {
    INFO() << "Sending SIGTERM to process " << child_process_;
    kill(child_process_, SIGTERM);
    waitpid(child_process_,NULL,WEXITED);
  }
  INFO() << "Puppet destroyed.";
}

void Puppet::spawn(String command)
{
  INFO() << "Spawning " << command;
  if( (child_process_=fork())==0 ) { // child
    execlp("sh","sh","-c",command.c_str(),(char *)NULL);
    exit(0);
  } // else parent
}



tamed void Puppet::connect(String hostname, int port, tamer::event<> ev)
{
  tvars {
    struct in_addr hostip;
    tamer::fd cfd;
    msgpack_fd mpfd;
  }

  if( !get_ip_address( hostname.c_str(), hostip ) ) {
    ERROR() << "Can't find " << hostname << ": " << strerror(errno);
    exit(-1);
  }
  
  INFO() << "Connecting to " << inet_ntoa(hostip) << ":" << port;

  twait { tamer::tcp_connect(hostip, port, make_event(cfd)); }
  if( !cfd ) {
    ERROR() << "Couldn't connect to " << hostname << ": " << strerror(-cfd.error());
    exit(-1);
  }

  mpfd_.initialize(cfd);

  ev();
}

void Puppet::disconnect()
{

}

// Basic operations

tamed void Puppet::send_print(String name, tamer::event<> ev)
{
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("print"),name));
    RPC_Msg reply;
  }

  INFO() << "Sending puppet command: print";

  twait { mpfd_.call(request,make_event(reply.json())); }

  // FIXME: validate
  // FIXME: assert not NACK
  ev();
}

tamed void Puppet::send_die(tamer::event<> ev){
  tvars {
    Json msg;
  }

  INFO() << "Sending puppet command: die";

  // FIXME

  ev();
}

tamed void Puppet::send_sleep(int seconds, tamer::event<> ev)
{
  INFO() << "Sending puppet command: sleep";

  // FIXME

  ev();
}

// Client Operations

tamed void Puppet::send_getroot(String lhs, tamer::event<> ev)
{
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("getroot"))); // FIXME: lhs
    RPC_Msg reply;
  }
  INFO() << "Sending puppet command: getroot";

  twait { mpfd_.call(request,make_event(reply.json())); }
  if( !mpfd_ ) {
    WARN() << "Puppet client hung up unexpectedly";
    ev();
  }
  INFO() << "Received: " << reply.json();

  // FIXME: validate
  // FIXME: assert not NACK

  ev();
}

tamed void Puppet::send_open(String lhs, String root, String subpath, tamer::event<> ev)
{
  INFO() << "Sending puppet command: open";

  ev();
}

tamed void Puppet::send_mkfile(String lhs, String path, String data, tamer::event<> ev) {
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("mkfile"),Json::array(path,data))); // FIXME: lhs
    RPC_Msg reply;
  }
  INFO() <<  "Sending puppet command: mkfile";

  twait { mpfd_.call(request,make_event(reply.json())); }
  INFO() << "Received: " << reply.json();
  
  ev();
}
tamed void Puppet::send_mkdir(String lhs, String path, tamer::event<> ev) {
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("mkdir"),Json::array(path))); // FIXME: lhs
    RPC_Msg reply;
  }
  INFO() <<  "Sending puppet command: mkdir";

  twait { mpfd_.call(request,make_event(reply.json())); }
  INFO() << "Received: " << reply.json();
  
  ev();
}
tamed void Puppet::send_getcontents(String lhs, String path, tamer::event<> ev) {
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("getcontents"),Json::array(path))); // FIXME: lhs
    RPC_Msg reply;
  }
  INFO() <<  "Sending puppet command: getcontents";

  twait { mpfd_.call(request,make_event(reply.json())); }
  INFO() << "Received: " << reply.json();
  
  ev();
}
tamed void Puppet::send_putcontents(String lhs, String path,String data, tamer::event<> ev) {
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("putcontents"),Json::array(path,data))); // FIXME: lhs
    RPC_Msg reply;
  }
  INFO() <<  "Sending puppet command: putcontents";

  twait { mpfd_.call(request,make_event(reply.json())); }
  INFO() << "Received: " << reply.json();
  
  ev();
}
tamed void Puppet::send_readdir(String lhs, String path, tamer::event<> ev) {
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("readdir"),Json::array(path))); // FIXME: lhs
    RPC_Msg reply;
  }
  INFO() <<  "Sending puppet command: readdir";

  twait { mpfd_.call(request,make_event(reply.json())); }
  INFO() << "Received: " << reply.json();
  
  ev();
}
tamed void Puppet::send_stat(String lhs, String path, tamer::event<> ev) {
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("stat"),Json::array(path))); // FIXME: lhs
    RPC_Msg reply;
  }
  INFO() <<  "Sending puppet command: stat";

  twait { mpfd_.call(request,make_event(reply.json())); }
  INFO() << "Received: " << reply.json();
  
  ev();
}
tamed void Puppet::send_remove(String lhs, String path, tamer::event<> ev) {
  tvars {
    RPC_Msg request = RPC_Msg(Json::array(String("remove"),Json::array(path))); // FIXME: lhs
    RPC_Msg reply;
  }
  INFO() <<  "Sending puppet command: remove";

  twait { mpfd_.call(request,make_event(reply.json())); }
  INFO() << "Received: " << reply.json();
  
  ev();
}

////////////////////////////////////////////////////////////////////////////////
// Puppet Server

#define WATCHDOG_TIMER 1

class Puppet_Server
{
private:
  tamer::fd listen_fd_;
  tamer::fd client_fd_;
  msgpack_fd client_mpfd_;
public:
  Puppet_Server(int port);

  // Basic operations
  tamed void run_puppet_server(int port);
  tamed void read_and_dispatch();
  virtual void dispatch(String tag, Json args, tamer::event<> ev); // called from above, but extensible.

  // Remote operations
  tamed void service_print(Json args, tamer::event<> ev);
  tamed void service_die(Json args, tamer::event<> ev);
  tamed void service_sleep(Json args, tamer::event<> ev);
};

Puppet_Server::Puppet_Server(int port=15808)
{
  run_puppet_server(port);
}

tamed void Puppet_Server::run_puppet_server(int port)
{
  tvars { 
    tamer::fd cfd;
  }
  listen_fd_ = tamer::tcp_listen(port);
  if( !listen_fd_ ) {
    ERROR() << "Puppet failed to listen: " << strerror(-listen_fd_.error());
    exit(-1);
  }
  INFO() << "Puppet listening on port " << port;

  while(listen_fd_) {
    twait {
      listen_fd_.accept(make_event(cfd));
    }
    INFO() << "Puppet received connection event";
    client_mpfd_.initialize(cfd);
    read_and_dispatch();
  }
}

tamed void Puppet_Server::read_and_dispatch()
{
  tvars {
    RPC_Msg request, reply;
    String tag;
  }

  while(client_mpfd_) {
    twait{ client_mpfd_.read_request(tamer::make_event(request.json())); }
    if( !client_mpfd_ ) {
      INFO() << "Client connection closed";
      break;
    }
    INFO() << "Puppet received RPC Msg: " << request.json();
    if(request.validate() ) {
      reply = RPC_Msg(Json::array(String("ACK")),request);
    } else {
      reply = RPC_Msg(Json::array(String("NACK")),request);
      continue; // Don't dispatch on invalid RPCs.
    }
    // FIXME:
    // This is a little odd. We write the reply *first*, before the
    // action has been taken. This is because some of the operations
    // do not return or block. We want to be able to make progress
    // in the puppet server. There is probably a better way to do this.
    INFO() << "Puppet server sending reply";
    client_mpfd_.write(reply);
    tag = request.content()[0].as_s();
    INFO() << "Dispatching: " << tag;
    twait { dispatch(tag, request.content(), make_event()); }
  }
  //client_mpfd_.close(); // FIXME: Do I need this? This loop will only break when the connection has been closed on the other end.
}

void Puppet_Server::dispatch(String tag, Json args, tamer::event<> ev)
{
  if(tag=="print") {
    service_print(args, ev);
  } else if(tag=="sleep") {
    service_sleep(args, ev);
  } else if(tag=="die") {
    service_die(args, ev);
  }

  INFO() << "Puppet dispatch finished.";
  // No warning about unknown messages, to allow extensibility via inheritance
  // Child class will call its own dispatch after this.
}

void Puppet_Server::service_print(Json args, tamer::event<> ev)
{
  INFO() << "Puppet printing";

  std::cout << args[1] << "\n";

  ev();
}

void Puppet_Server::service_die(Json args, tamer::event<> ev)
{
  INFO() << "Puppet dying";

  exit(0); // Everything stops. Do not pass Go, do not collect $200.
}

tamed void Puppet_Server::service_sleep(Json args, tamer::event<> ev)
{
  tvars {
    int i;
  }
  if( !args[1].is_i() ) {
    return;
  }
  i = args[1].as_i();
  assert((i>0) && (i<1000) && "Ridiculous sleep time requested. Corruption?\n");
  INFO() << "Puppet sleeping.";

  twait { tamer::at_delay(i,make_event()); }

  ev();
}

} // namespace puppet
